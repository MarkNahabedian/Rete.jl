<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · Rete.jl</title><meta name="title" content="Home · Rete.jl"/><meta property="og:title" content="Home · Rete.jl"/><meta property="twitter:title" content="Home · Rete.jl"/><meta name="description" content="Documentation for Rete.jl."/><meta property="og:description" content="Documentation for Rete.jl."/><meta property="twitter:description" content="Documentation for Rete.jl."/><meta property="og:url" content="https://MarkNahabedian.github.io/Rete.jl/"/><meta property="twitter:url" content="https://MarkNahabedian.github.io/Rete.jl/"/><link rel="canonical" href="https://MarkNahabedian.github.io/Rete.jl/"/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>Rete.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Facts"><span>Facts</span></a></li><li><a class="tocitem" href="#The-Network"><span>The Network</span></a></li><li><a class="tocitem" href="#Flow-of-Facts-through-the-Network"><span>Flow of Facts through the Network</span></a></li><li><a class="tocitem" href="#Rules"><span>Rules</span></a></li><li><a class="tocitem" href="#Backward-Chaining"><span>Backward Chaining</span></a></li><li><a class="tocitem" href="#Querying-and-Aggregation"><span>Querying and Aggregation</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li><li><a class="tocitem" href="#Glossary"><span>Glossary</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/MarkNahabedian/Rete.jl/blob/main/docs/src/index.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Rete"><a class="docs-heading-anchor" href="#Rete">Rete</a><a id="Rete-1"></a><a class="docs-heading-anchor-permalink" href="#Rete" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/MarkNahabedian/Rete.jl">Rete</a>.</p><p>Rete currently implements memory for Julia types, forward chaining joins, and backward chaining filter and extrema operations.</p><h2 id="Facts"><a class="docs-heading-anchor" href="#Facts">Facts</a><a id="Facts-1"></a><a class="docs-heading-anchor-permalink" href="#Facts" title="Permalink"></a></h2><p>The <em>facts</em> in our reasoning system can be arbitrary Julia objects. It&#39;s best to restrict <em>facts</em> to immutable objects though so that they can&#39;t be altered once they&#39;re stored in the network or conclusions have been made.  There is no mechanism for retracting a conclusion if a fact is altered.</p><h2 id="The-Network"><a class="docs-heading-anchor" href="#The-Network">The Network</a><a id="The-Network-1"></a><a class="docs-heading-anchor-permalink" href="#The-Network" title="Permalink"></a></h2><p>The reasoning is performed by a network of nodes.  <em>Facts</em> flow through the network from node to node.</p><p>Each node has a set of input nodes (those that send it <em>facts</em>), and a set of outputs (those nodes to which it sends <em>facts</em>). <a href="#Rete.connect-Tuple{AbstractReteNode, AbstractReteNode}"><code>connect</code></a> is used to construct the network by linking nodes together.</p><p>Some nodes filter the <em>facts</em> and only pass through those that satisfy some predicate or are instances of a certain type.</p><p>Some nodes store <em>facts</em>.</p><p>Join nodes have multiple distinct input streams.  A function is applied to all possible combinations of facts coming in from these streams.  The function can call <a href="#Rete.emit"><code>emit</code></a> to assert a new <em>fact</em> to the network.</p><p>That&#39;s the theory.  In practice, its simpler if a given node performs more than one of these roles.  One such example is <a href="#Rete.IsaMemoryNode"><code>IsaMemoryNode</code></a>, which filters <em>facts</em> that match a type parameter and remember only those <em>facts</em>.</p><p>We assume that the network is fully constructed before any facts are asserted.  Adding inputs to a JoinNode doesn&#39;t cause existing facts from those inputs to be processed.</p><h3 id="Layers"><a class="docs-heading-anchor" href="#Layers">Layers</a><a id="Layers-1"></a><a class="docs-heading-anchor-permalink" href="#Layers" title="Permalink"></a></h3><p>The network might best be constructed in layers.  A single root node forms the top layer.  It serves as the recipient of new facts.  It distributes those facts to the next layer, which consists of memory nodes.  A third layer consists of join nodes, typically defined by rules.  The join nodes might conclude new facts which they pass to the root node.</p><h2 id="Flow-of-Facts-through-the-Network"><a class="docs-heading-anchor" href="#Flow-of-Facts-through-the-Network">Flow of Facts through the Network</a><a id="Flow-of-Facts-through-the-Network-1"></a><a class="docs-heading-anchor-permalink" href="#Flow-of-Facts-through-the-Network" title="Permalink"></a></h2><p>A node receives a <em>fact</em> via its <a href="#Rete.receive"><code>receive</code></a> method.</p><p>A node distributes a <em>fact</em> to its outputs using its <a href="#Rete.emit"><code>emit</code></a> method, which calls <a href="#Rete.receive"><code>receive</code></a> for each of the node&#39;s outputs.</p><h2 id="Rules"><a class="docs-heading-anchor" href="#Rules">Rules</a><a id="Rules-1"></a><a class="docs-heading-anchor-permalink" href="#Rules" title="Permalink"></a></h2><p>The <a href="#Rete.@rule-Tuple{Any, Any}"><code>@rule</code></a> macro makes it easier to create rules and add them to a Rete.</p><p>As a contrived exanple, lets create a network that creates pairs of letters when the second letter in the pair is the next letter of the alphabet from the first.</p><pre><code class="language-julia hljs">using Rete

@rule PairConsectutiveLetters(a::Char, b::Char, ::String) begin
    if codepoint(a) + 1 == codepoint(b)
        emit(a * b)
    end
end</code></pre><p><a href="#Rete.@rule-Tuple{Any, Any}"><code>@rule</code></a> will define a singleton type named <code>PairConsectutiveLetters</code> to represent the rule.  <code>@rule</code> defines an <code>install</code> method that will add the rule to a network.  The instance of <code>PairConsectutiveLetters</code> implements the join function of the JoinNode.</p><pre><code class="language-julia hljs"># Create the knowledgebase:
root = ReteRootNode(&quot;root&quot;)
install(root, PairConsectutiveLetters())

# Assert the characters &#39;a&#39; through &#39;e&#39; into the knowledgebase:
for c in &#39;a&#39;:&#39;e&#39;
    receive(root, c)
end

askc(Collector{String}(), root)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4-element Vector{String}:
 &quot;ab&quot;
 &quot;bc&quot;
 &quot;cd&quot;
 &quot;de&quot;</code></pre><h2 id="Backward-Chaining"><a class="docs-heading-anchor" href="#Backward-Chaining">Backward Chaining</a><a id="Backward-Chaining-1"></a><a class="docs-heading-anchor-permalink" href="#Backward-Chaining" title="Permalink"></a></h2><p>Rete currently provides limited support for backward chaining by using the <a href="#Rete.BackwardFilterNode"><code>BackwardFilterNode</code></a> and <a href="#Rete.BackwardExtremumNode"><code>BackwardExtremumNode</code></a> node types.</p><p>There is not yet any facility to make it easier to integrate these nodes into the network.  You will need to use the node constructors and <a href="#Rete.connect-Tuple{AbstractReteNode, AbstractReteNode}"><code>connect</code></a> to add them by hand.</p><h2 id="Querying-and-Aggregation"><a class="docs-heading-anchor" href="#Querying-and-Aggregation">Querying and Aggregation</a><a id="Querying-and-Aggregation-1"></a><a class="docs-heading-anchor-permalink" href="#Querying-and-Aggregation" title="Permalink"></a></h2><p>The function <a href="#Rete.askc"><code>askc</code></a> can be used to query the network.  <code>askc</code> takes either a continuation function or an <a href="#Rete.Aggregator"><code>Aggregator</code></a> as its first argument.</p><p><code>askc</code> also takes either a node that supports it, e.g. memory nodes or backweard chaining nodes; or a <a href="#Rete.ReteRootNode"><code>ReteRootNode</code></a> representing your knowledge base, and a fact type.</p><p>The continuation finction is callled on each fact that <code>askc</code> finds.</p><p>If an aggregator is passed as the first argument then it will perform the specified aggregation over the course of the query and that call to <code>askc</code> will return the aggregation result.</p><p>The currenty supported aggregators are:</p><ul><li><a href="#Rete.Counter"><code>Counter</code></a></li><li><a href="#Rete.Collector"><code>Collector</code></a></li></ul><pre><code class="language-julia hljs">using Rete
kb = ReteRootNode(&quot;My Knowledge Base&quot;)
connect(kb, IsaMemoryNode{Int}())
receive.([kb], 1:5)
nothing</code></pre><pre><code class="language-julia hljs">askc(Counter(), kb, Int)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5</code></pre><pre><code class="language-julia hljs">askc(Collector{Int}(), kb)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5-element Vector{Int64}:
 1
 2
 3
 4
 5</code></pre><p>Note that <code>askc</code> can infer its third argument from the <code>Collector</code>.</p><pre><code class="language-julia hljs">let
    sum = 0
    askc(kb, Int) do i
        sum += i
    end
    sum
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">15</code></pre><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#Rete.AbstractMemoryNode"><code>Rete.AbstractMemoryNode</code></a></li><li><a href="#Rete.AbstractReteJoinNode"><code>Rete.AbstractReteJoinNode</code></a></li><li><a href="#Rete.AbstractReteNode"><code>Rete.AbstractReteNode</code></a></li><li><a href="#Rete.AbstractReteRootNode"><code>Rete.AbstractReteRootNode</code></a></li><li><a href="#Rete.Aggregator"><code>Rete.Aggregator</code></a></li><li><a href="#Rete.BackwardChaining"><code>Rete.BackwardChaining</code></a></li><li><a href="#Rete.BackwardExtremumNode"><code>Rete.BackwardExtremumNode</code></a></li><li><a href="#Rete.BackwardFilterNode"><code>Rete.BackwardFilterNode</code></a></li><li><a href="#Rete.CanInstallRulesTrait"><code>Rete.CanInstallRulesTrait</code></a></li><li><a href="#Rete.Collector"><code>Rete.Collector</code></a></li><li><a href="#Rete.Counter"><code>Rete.Counter</code></a></li><li><a href="#Rete.HasSetOfInputsTrait"><code>Rete.HasSetOfInputsTrait</code></a></li><li><a href="#Rete.HasSetOfOutputsTrait"><code>Rete.HasSetOfOutputsTrait</code></a></li><li><a href="#Rete.IsaMemoryNode"><code>Rete.IsaMemoryNode</code></a></li><li><a href="#Rete.JoinNode"><code>Rete.JoinNode</code></a></li><li><a href="#Rete.ReteRootNode"><code>Rete.ReteRootNode</code></a></li><li><a href="#Rete.Rule"><code>Rete.Rule</code></a></li><li><a href="#Rete._add_input"><code>Rete._add_input</code></a></li><li><a href="#Rete._add_output"><code>Rete._add_output</code></a></li><li><a href="#Rete.add_forward_trigger-Tuple{JoinNode, AbstractReteNode}"><code>Rete.add_forward_trigger</code></a></li><li><a href="#Rete.askc-Tuple{Function, AbstractReteRootNode, Type}"><code>Rete.askc</code></a></li><li><a href="#Rete.askc"><code>Rete.askc</code></a></li><li><a href="#Rete.connect-Tuple{AbstractReteNode, AbstractReteNode}"><code>Rete.connect</code></a></li><li><a href="#Rete.copy_facts-Tuple{AbstractReteRootNode, AbstractReteRootNode, Any}"><code>Rete.copy_facts</code></a></li><li><a href="#Rete.emit"><code>Rete.emit</code></a></li><li><a href="#Rete.emits-Tuple{Any}"><code>Rete.emits</code></a></li><li><a href="#Rete.ensure_memory_node-Tuple{AbstractReteRootNode, Type}"><code>Rete.ensure_memory_node</code></a></li><li><a href="#Rete.fact_count-Tuple{AbstractReteNode}"><code>Rete.fact_count</code></a></li><li><a href="#Rete.find_memory_for_type-Tuple{AbstractReteRootNode, Type}"><code>Rete.find_memory_for_type</code></a></li><li><a href="#Rete.input_count-Tuple{AbstractReteNode}"><code>Rete.input_count</code></a></li><li><a href="#Rete.inputs"><code>Rete.inputs</code></a></li><li><a href="#Rete.install-Union{Tuple{T}, Tuple{T, Type}} where T"><code>Rete.install</code></a></li><li><a href="#Rete.is_forward_trigger-Tuple{JoinNode, AbstractReteNode}"><code>Rete.is_forward_trigger</code></a></li><li><a href="#Rete.is_memory_for_type-Tuple{IsaMemoryNode, Type}"><code>Rete.is_memory_for_type</code></a></li><li><a href="#Rete.kb_counts-Tuple{AbstractReteRootNode}"><code>Rete.kb_counts</code></a></li><li><a href="#Rete.kb_stats-Tuple{Any, Any}"><code>Rete.kb_stats</code></a></li><li><a href="#Rete.label"><code>Rete.label</code></a></li><li><a href="#Rete.output_count-Tuple{AbstractReteNode}"><code>Rete.output_count</code></a></li><li><a href="#Rete.outputs"><code>Rete.outputs</code></a></li><li><a href="#Rete.receive"><code>Rete.receive</code></a></li><li><a href="#Rete.walk_by_outputs-Tuple{Any, AbstractReteNode}"><code>Rete.walk_by_outputs</code></a></li><li><a href="#Rete.@rule-Tuple{Any, Any}"><code>Rete.@rule</code></a></li></ul><h2 id="Glossary"><a class="docs-heading-anchor" href="#Glossary">Glossary</a><a id="Glossary-1"></a><a class="docs-heading-anchor-permalink" href="#Glossary" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rete.AbstractMemoryNode" href="#Rete.AbstractMemoryNode"><code>Rete.AbstractMemoryNode</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>AbstractMemoryNode is the abstract supertype of all Rete memory nodes.</p><p>Each concrete sybtype should implement <a href="#Rete.is_memory_for_type-Tuple{IsaMemoryNode, Type}"><code>is_memory_for_type</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MarkNahabedian/Rete.jl/blob/b6b931103d714245d3ad319e8735588eeda2d06c/src/node_abstraction.jl#L16-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rete.AbstractReteJoinNode" href="#Rete.AbstractReteJoinNode"><code>Rete.AbstractReteJoinNode</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>AbstractReteJoinNode is the abstract supertype of all Rete join nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MarkNahabedian/Rete.jl/blob/b6b931103d714245d3ad319e8735588eeda2d06c/src/node_abstraction.jl#L24-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rete.AbstractReteNode" href="#Rete.AbstractReteNode"><code>Rete.AbstractReteNode</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>AbstractReteNode is the abstract supertype of all Rete nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MarkNahabedian/Rete.jl/blob/b6b931103d714245d3ad319e8735588eeda2d06c/src/node_abstraction.jl#L10-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rete.AbstractReteRootNode" href="#Rete.AbstractReteRootNode"><code>Rete.AbstractReteRootNode</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractReteRootNode</code></pre><p>AbstractReteRootNode is the abstract supertype for all root nodes of a Rete.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MarkNahabedian/Rete.jl/blob/b6b931103d714245d3ad319e8735588eeda2d06c/src/root_nodes.jl#L40-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rete.Aggregator" href="#Rete.Aggregator"><code>Rete.Aggregator</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Aggergator is the abstract supertype for all query aggregators.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MarkNahabedian/Rete.jl/blob/b6b931103d714245d3ad319e8735588eeda2d06c/src/aggregation.jl#L4-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rete.BackwardChaining" href="#Rete.BackwardChaining"><code>Rete.BackwardChaining</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>BackwardChaining is the abstract supertype for all backward chaining Rete nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MarkNahabedian/Rete.jl/blob/b6b931103d714245d3ad319e8735588eeda2d06c/src/backward.jl#L6-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rete.BackwardExtremumNode" href="#Rete.BackwardExtremumNode"><code>Rete.BackwardExtremumNode</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>BackwardExtremumNode(comparison, extractor, label)</p><p>When <code>askc</code>ed, provides one value: the fact with the most extreme value (based on <code>comparison</code>) of <code>extractor</code> applied to each input fact at the time <code>askc</code> was called.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MarkNahabedian/Rete.jl/blob/b6b931103d714245d3ad319e8735588eeda2d06c/src/backward.jl#L56-L63">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rete.BackwardFilterNode" href="#Rete.BackwardFilterNode"><code>Rete.BackwardFilterNode</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs"> BackwardFilterNode(filter_function, label)</code></pre><p>When <code>askc</code>ed, passes through from its inputs only those facts which satisfy <code>predicate</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MarkNahabedian/Rete.jl/blob/b6b931103d714245d3ad319e8735588eeda2d06c/src/backward.jl#L18-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rete.CanInstallRulesTrait" href="#Rete.CanInstallRulesTrait"><code>Rete.CanInstallRulesTrait</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CanInstallRulesTrait</code></pre><p>Having this trait gives the root node of a knowledge base the <code>install</code> method to facilitate adding rules to the network.</p><p>You can add this trait to <code>YourType</code> with</p><pre><code class="nohighlight hljs">CanInstallRulesTrait(::Type{&lt;:YourType}) = CanInstallRulesTrait())</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MarkNahabedian/Rete.jl/blob/b6b931103d714245d3ad319e8735588eeda2d06c/src/root_nodes.jl#L6-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rete.Collector" href="#Rete.Collector"><code>Rete.Collector</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Collector{T}()</code></pre><p>returns an Aggregator that can be passed as the &quot;continuation&quot; function of <code>askc</code> so that <code>askc</code> will return a vector of the objects that it found.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MarkNahabedian/Rete.jl/blob/b6b931103d714245d3ad319e8735588eeda2d06c/src/aggregation.jl#L45-L51">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rete.Counter" href="#Rete.Counter"><code>Rete.Counter</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Counter()</code></pre><p>returns an Aggregator that can be passed as the &quot;continuation&quot; function of <code>askc</code> so that <code>askc</code> will return the number of objects that it found.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MarkNahabedian/Rete.jl/blob/b6b931103d714245d3ad319e8735588eeda2d06c/src/aggregation.jl#L25-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rete.HasSetOfInputsTrait" href="#Rete.HasSetOfInputsTrait"><code>Rete.HasSetOfInputsTrait</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">HasSetOfInputsTrait(type)</code></pre><p>A Rete node type with the HasSetOfInputsTrait stores its inputs as a set.</p><p>Any struct that is a subtype of AbstractReteNode with the field</p><pre><code class="nohighlight hljs">    inputs::Set{AbstractReteNode}</code></pre><p>will have this trait.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MarkNahabedian/Rete.jl/blob/b6b931103d714245d3ad319e8735588eeda2d06c/src/sets_as_inputs_and_outputs.jl#L55-L68">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rete.HasSetOfOutputsTrait" href="#Rete.HasSetOfOutputsTrait"><code>Rete.HasSetOfOutputsTrait</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">HasSetOfOuputsTrait(type)</code></pre><p>A Rete node type with the HasSetOfOutputsTrait stores its outputs as a set.</p><p>Any struct that is a subtype of AbstractReteNode with the field</p><pre><code class="nohighlight hljs">    outputs::Set{AbstractReteNode}</code></pre><p>will have this trait.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MarkNahabedian/Rete.jl/blob/b6b931103d714245d3ad319e8735588eeda2d06c/src/sets_as_inputs_and_outputs.jl#L88-L101">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rete.IsaMemoryNode" href="#Rete.IsaMemoryNode"><code>Rete.IsaMemoryNode</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>IsaMemoryNode is a type of memory node that only stores facts of the specified type.  Facts of other types are ignored.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MarkNahabedian/Rete.jl/blob/b6b931103d714245d3ad319e8735588eeda2d06c/src/memory_nodes.jl#L19-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rete.JoinNode" href="#Rete.JoinNode"><code>Rete.JoinNode</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>JoinNode implements a join operation between multiple streams of inputs.  The first argiment of <code>join_function</code> is the JoinNode itself. The remaining arguments come from the input streams of the join node. <code>join_function</code> should call <code>emit</code> for each new fact it wants to assert.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MarkNahabedian/Rete.jl/blob/b6b931103d714245d3ad319e8735588eeda2d06c/src/join_nodes.jl#L7-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rete.ReteRootNode" href="#Rete.ReteRootNode"><code>Rete.ReteRootNode</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ReteRootNode</code></pre><p>ReteRootNode serves as the root node of a Rete network.</p><p>If you need a specialized root node for your application, see <a href="#Rete.AbstractReteRootNode"><code>AbstractReteRootNode</code></a> and <a href="#Rete.CanInstallRulesTrait"><code>CanInstallRulesTrait</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MarkNahabedian/Rete.jl/blob/b6b931103d714245d3ad319e8735588eeda2d06c/src/root_nodes.jl#L49-L56">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rete.Rule" href="#Rete.Rule"><code>Rete.Rule</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Rule is an abstract supertype for all rules.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MarkNahabedian/Rete.jl/blob/b6b931103d714245d3ad319e8735588eeda2d06c/src/rules.jl#L6-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rete._add_input" href="#Rete._add_input"><code>Rete._add_input</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_add_input(from, to)</code></pre><p>adds <code>from</code> as an input to <code>to</code>.</p><p>User code should never call <code>_add_input</code> directly, only through <code>connect</code>.  Users might specialize <code>_add_input</code> if implementing a node that needs to specialize how it storesa its inputs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MarkNahabedian/Rete.jl/blob/b6b931103d714245d3ad319e8735588eeda2d06c/src/sets_as_inputs_and_outputs.jl#L31-L39">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rete._add_output" href="#Rete._add_output"><code>Rete._add_output</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_add_output(from, to)</code></pre><p>adds <code>to</code> as an output of <code>from</code>.</p><p>User code should never call <code>_add_output</code> directly, only through <code>connect</code>.  Users might specialize <code>_add_output</code> if implementing a node that needs to specialize how it storesa its outputs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MarkNahabedian/Rete.jl/blob/b6b931103d714245d3ad319e8735588eeda2d06c/src/sets_as_inputs_and_outputs.jl#L43-L51">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rete.add_forward_trigger-Tuple{JoinNode, AbstractReteNode}" href="#Rete.add_forward_trigger-Tuple{JoinNode, AbstractReteNode}"><code>Rete.add_forward_trigger</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_forward_trigger(n::JoinNode, from::AbstractReteNode)</code></pre><p>adds <code>from</code> as a forward trigger of the JoinNode.</p><p>When a JoinNode <code>receive</code>s a fact from one of its forward trigger inputs, it joins that input with all combinations of facts from other inputs and performs its <code>join_function</code>.  Otherwise the JoinNode is not triggered.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MarkNahabedian/Rete.jl/blob/b6b931103d714245d3ad319e8735588eeda2d06c/src/join_nodes.jl#L48-L57">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rete.askc" href="#Rete.askc"><code>Rete.askc</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">askc(continuation::Function, node)</code></pre><p>Calls <code>continuation</code> on each <em>fact</em> available from <code>node</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MarkNahabedian/Rete.jl/blob/b6b931103d714245d3ad319e8735588eeda2d06c/src/node_abstraction.jl#L117-L121">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rete.askc-Tuple{Function, AbstractReteRootNode, Type}" href="#Rete.askc-Tuple{Function, AbstractReteRootNode, Type}"><code>Rete.askc</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">askc(continuation::Function, root::AbstractReteRootNode, t::Type)</code></pre><p>calls <code>continuation</code> on every fact of the specified type (or its subtypes) that are stored in the network rooted at <code>root</code>.</p><p>Assumes all memory nodes are direct outputs of <code>root</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MarkNahabedian/Rete.jl/blob/b6b931103d714245d3ad319e8735588eeda2d06c/src/memory_nodes.jl#L75-L82">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rete.connect-Tuple{AbstractReteNode, AbstractReteNode}" href="#Rete.connect-Tuple{AbstractReteNode, AbstractReteNode}"><code>Rete.connect</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">connect(from::AbstractReteNode, to::AbstractReteNode)</code></pre><p>makes <code>to</code> an output of <code>from</code> and <code>from</code> an input of <code>to</code>.</p><p><code>connect</code> calls <a href="#Rete._add_input"><code>_add_input</code></a> and <a href="#Rete._add_output"><code>_add_output</code></a> to do this.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MarkNahabedian/Rete.jl/blob/b6b931103d714245d3ad319e8735588eeda2d06c/src/sets_as_inputs_and_outputs.jl#L16-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rete.copy_facts-Tuple{AbstractReteRootNode, AbstractReteRootNode, Any}" href="#Rete.copy_facts-Tuple{AbstractReteRootNode, AbstractReteRootNode, Any}"><code>Rete.copy_facts</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">copy_facts(from_kb::AbstractReteRootNode, to_kb::AbstractReteRootNode, fact_types)</code></pre><p>Copues facts if the specified <code>fact_type</code> from <code>from_kb</code> to <code>to_kb</code>.</p><p>for multiple fact types, one can broadcast over a collection of fact types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MarkNahabedian/Rete.jl/blob/b6b931103d714245d3ad319e8735588eeda2d06c/src/utils.jl#L59-L66">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rete.emit" href="#Rete.emit"><code>Rete.emit</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">emit(node, fact)</code></pre><p>Distribute&#39;s <code>fact</code> to each of <code>node</code>&#39;s outputs by calling <a href="#Rete.receive"><code>receive</code></a> on the output node and <code>fact</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MarkNahabedian/Rete.jl/blob/b6b931103d714245d3ad319e8735588eeda2d06c/src/node_abstraction.jl#L91-L96">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rete.emits-Tuple{Any}" href="#Rete.emits-Tuple{Any}"><code>Rete.emits</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">emits(rule::Type)</code></pre><p>Returns a Tuple of the types which <code>rule</code> is declared to emit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MarkNahabedian/Rete.jl/blob/b6b931103d714245d3ad319e8735588eeda2d06c/src/rules.jl#L16-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rete.ensure_memory_node-Tuple{AbstractReteRootNode, Type}" href="#Rete.ensure_memory_node-Tuple{AbstractReteRootNode, Type}"><code>Rete.ensure_memory_node</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ensure_memory_node(root::AbstractReteRootNode, typ::Type)::IsaTypeNode</code></pre><p>Find a memory node for the specified type, or make one and add it to the network.</p><p>The default is to make an IsaMemoryNode.  Specialize this function for a <code>Type</code> to control what type of memory node should be used for that type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MarkNahabedian/Rete.jl/blob/b6b931103d714245d3ad319e8735588eeda2d06c/src/memory_nodes.jl#L115-L124">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rete.fact_count-Tuple{AbstractReteNode}" href="#Rete.fact_count-Tuple{AbstractReteNode}"><code>Rete.fact_count</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fact_count(node)</code></pre><p>For memory nodes, return the number of facts currently stored in the node&#39;s memory, otherwise return <code>nothing</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MarkNahabedian/Rete.jl/blob/b6b931103d714245d3ad319e8735588eeda2d06c/src/node_abstraction.jl#L76-L81">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rete.find_memory_for_type-Tuple{AbstractReteRootNode, Type}" href="#Rete.find_memory_for_type-Tuple{AbstractReteRootNode, Type}"><code>Rete.find_memory_for_type</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">find_memory_for_type(root, typ::Type)::Union(Nothing, AbstractMemoryNode}</code></pre><p>If there&#39;s a memory node in the Rete represented by <code>root</code> that stores objects of the specified type then return it.  Otherwise return nothing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MarkNahabedian/Rete.jl/blob/b6b931103d714245d3ad319e8735588eeda2d06c/src/memory_nodes.jl#L96-L102">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rete.input_count-Tuple{AbstractReteNode}" href="#Rete.input_count-Tuple{AbstractReteNode}"><code>Rete.input_count</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">input_count(node)</code></pre><p>returns the number of inputs to the node.</p><p>Note that for join nodes, this is the number of parameters rather than the number of nodes that emit facts to the join.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MarkNahabedian/Rete.jl/blob/b6b931103d714245d3ad319e8735588eeda2d06c/src/node_abstraction.jl#L57-L64">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rete.inputs" href="#Rete.inputs"><code>Rete.inputs</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">inputs(node)</code></pre><p>Returns the inputs of <code>node</code> – those nodes which can send it <em>facts</em> – as an iterable collection.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MarkNahabedian/Rete.jl/blob/b6b931103d714245d3ad319e8735588eeda2d06c/src/node_abstraction.jl#L39-L44">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rete.install-Union{Tuple{T}, Tuple{T, Type}} where T" href="#Rete.install-Union{Tuple{T}, Tuple{T, Type}} where T"><code>Rete.install</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">install(root, rule::Type)</code></pre><p>Installs the rule or rule group into the Rete rooted at <code>root</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MarkNahabedian/Rete.jl/blob/b6b931103d714245d3ad319e8735588eeda2d06c/src/root_nodes.jl#L21-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rete.is_forward_trigger-Tuple{JoinNode, AbstractReteNode}" href="#Rete.is_forward_trigger-Tuple{JoinNode, AbstractReteNode}"><code>Rete.is_forward_trigger</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_forward_trigger(::JoinNode, from::AbstractReteNode)</code></pre><p>returns true if <code>from</code> is a forward trigger input of the JoinNode.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MarkNahabedian/Rete.jl/blob/b6b931103d714245d3ad319e8735588eeda2d06c/src/join_nodes.jl#L63-L67">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rete.is_memory_for_type-Tuple{IsaMemoryNode, Type}" href="#Rete.is_memory_for_type-Tuple{IsaMemoryNode, Type}"><code>Rete.is_memory_for_type</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_memory_for_type(node, typ::Type)::Bool</code></pre><p>returns <code>true</code> if <code>node</code> stores objects of the specified type.</p><p>Used by <a href="#Rete.find_memory_for_type-Tuple{AbstractReteRootNode, Type}"><code>find_memory_for_type</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MarkNahabedian/Rete.jl/blob/b6b931103d714245d3ad319e8735588eeda2d06c/src/memory_nodes.jl#L43-L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rete.kb_counts-Tuple{AbstractReteRootNode}" href="#Rete.kb_counts-Tuple{AbstractReteRootNode}"><code>Rete.kb_counts</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">kb_counts(root::AbstractReteRootNode)</code></pre><p>Returns a <code>Dict{Type, Int}</code> of the number of facts of each type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MarkNahabedian/Rete.jl/blob/b6b931103d714245d3ad319e8735588eeda2d06c/src/utils.jl#L5-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rete.kb_stats-Tuple{Any, Any}" href="#Rete.kb_stats-Tuple{Any, Any}"><code>Rete.kb_stats</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">kb_stats(io, root)</code></pre><p>Show the input count, output count, fact count and label for each node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MarkNahabedian/Rete.jl/blob/b6b931103d714245d3ad319e8735588eeda2d06c/src/utils.jl#L27-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rete.label" href="#Rete.label"><code>Rete.label</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">label(node)</code></pre><p>Returns <code>node</code>&#39;s label.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MarkNahabedian/Rete.jl/blob/b6b931103d714245d3ad319e8735588eeda2d06c/src/node_abstraction.jl#L30-L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rete.output_count-Tuple{AbstractReteNode}" href="#Rete.output_count-Tuple{AbstractReteNode}"><code>Rete.output_count</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">output_count(node)</code></pre><p>returns the number of outputs from the node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MarkNahabedian/Rete.jl/blob/b6b931103d714245d3ad319e8735588eeda2d06c/src/node_abstraction.jl#L68-L72">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rete.outputs" href="#Rete.outputs"><code>Rete.outputs</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">outputs(node)</code></pre><p>Returns the outputs of <code>node</code> – those nodes to which it can send <em>facts</em> – as an iterable collection.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MarkNahabedian/Rete.jl/blob/b6b931103d714245d3ad319e8735588eeda2d06c/src/node_abstraction.jl#L48-L53">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rete.receive" href="#Rete.receive"><code>Rete.receive</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">receive(node, fact)</code></pre><p><code>receive</code> is how <code>node</code> is given a new <em>fact</em>.</p><p>An application calls <code>receive</code> on the root node to assert a new fact to the network.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MarkNahabedian/Rete.jl/blob/b6b931103d714245d3ad319e8735588eeda2d06c/src/node_abstraction.jl#L106-L113">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rete.walk_by_outputs-Tuple{Any, AbstractReteNode}" href="#Rete.walk_by_outputs-Tuple{Any, AbstractReteNode}"><code>Rete.walk_by_outputs</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>walk<em>by</em>outputs(func, node::AbstractReteNode)</p><p>Walks the network rooted at `root&#39;, applying func to each node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MarkNahabedian/Rete.jl/blob/b6b931103d714245d3ad319e8735588eeda2d06c/src/node_abstraction.jl#L134-L138">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rete.@rule-Tuple{Any, Any}" href="#Rete.@rule-Tuple{Any, Any}"><code>Rete.@rule</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">@rule Rulename(a::A_Type, b::B_Type, ...) begin ... end</code></pre><p>Defines a rule named <code>Rulename</code>.  A singleton type named <code>Rulename</code> will be defined to represent the rule.  An <a href="#Rete.install-Union{Tuple{T}, Tuple{T, Type}} where T"><code>install</code></a> method is defined for that type which can be used to add the necessary nodes and connections to a Rete to implement the rule.</p><p>The default supertype of a rule struct is <code>Rule</code>.  When it is desirable to group rules together, one can define an abstract type that is a type descendant of Rule and use that as a dotted prefix to <code>RuleName</code>.  The <code>RuleName</code> in the @rule invocation is <code>MyGroup.MyRule</code> then the supertype of MyRule will be MyGroup, rather than <a href="#Rete.Rule"><code>Rule</code></a>.</p><p>A rule can have arbitrarily many parameters.  The parameter list can also include clauses with no variable name.  Such clauses identify the types of facts that the rule might assert.  Memory nodes for these types will be added to the Rete if not already present.</p><p>The first expression of the rule can be call-like expression of RULE_DECLARATIONS.  Its &quot;parameters&quot; can be declarations of one of the forms</p><p><code></code>FORWARD<em>TRIGGERS(argument</em>names...)`</p><p>Only the inputs for the specified argument names will serve as forward triggers.  For backward compatibility, if there is no RULE_DECLARATIONS expression then all inputs are forward triggers.</p><p><code></code>CUSTOM_INSTALL()`</p><p>No <code>install</code> method will be automatically generated.  The developer must implement an <code>install</code> method for this rule.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MarkNahabedian/Rete.jl/blob/b6b931103d714245d3ad319e8735588eeda2d06c/src/rules.jl#L59-L94">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Monday 2 December 2024 15:28">Monday 2 December 2024</span>. Using Julia version 1.11.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
